Trabalhando com Collections Java - Stream

ordem aleatoria   --> HashMap
ordem de insersão --> LinkedHashMap
organizar por id  --> TreeMap, passando um dicionario como argumento

stream dois tipos:
	operacoes intermediarias
		retorna um stream e podemos encadear operações
			op1().op2().op3() --> isso é encadear operações
	operacoes terminais
		só pode usar uma operação, não pode encadear várias operações, retorna valor ou objeto
			op1() --> so pode ser usado assim (?)

Consumer é uma interface funcional


ExerciciosStreamAPI.java

Operacao colect "pegue algo de algum lugar e colete para outro lugar"


SAM (Single Abstract Method) interface com um único método abstrato






Exercicios

List<String> numerosAleatorios = Arrays.asList("1", "0", "4", "1", "2", "3", "9", "6", "5");

------------> operações intermediárias

------------> imprimir todos os lementos dessa lista de String <--------------

//parte 1
numerosAleatorios.stream().forEach(new Consumer<String>() {
	@Override
	public void accept(String s) {
		System.out.println(s);
	}
});


//parte 2 - simplificando para lambda
numerosAleatorios.stream().forEach(s -> System.out.println(s));


//parte 3 - simplificando lambda, removendo stream
numerosAleatorios.forEach(s -> System.out.println(s));


//parte 4 - simplificando ainda mais com Reference Method
numerosAleatorios.forEach(s -> System.out::println);




--------> pegando os 5 primeiros numeros e colocando dentro de um Set <--------

numerosAleatorios.stream()
	.limit(5)
	.collect(Collectors.toSet())
	.forEach(System.out::println);


//podemos guardar esses 5 valores em uma variavel
Set<String> collectSet = numerosAleatorios.stream()
	.limit(5)
	.collect(Collectors.toSet());




----------> transformando lista de string ("1","2","3") em lista de inteiro (1,2,3) <------------
Vai continuar sendo uma list, porém de números inteiros.

numerosAleatorios.stream()
	.map(new Functon<String, Integer>() {
		@Override
		public Integer apply(String s) {
			return Integer.parseInt(s);
		}
	});


//parte 2 - simplificando para lambda
numerosAleatorios.stream()
	.map(s -> Integer.parseInt(s));


//parte 3 - simplificando ainda mais para reference method
numerosAleatorios.stream()
	.map(Integer::parseInt);


//parte 4 - transformando em numeros inteiros
numerosAleatorios.stream()
	.map(Integer::parseInt)
	.collect(Collectors.toList())
	.forEach(System.out::println);


//parte 5 - guardando numeros inteiros em uma List
List<Integer> collectList = numerosAleatorios.stream()
	.map(Integer::parseInt)
	.collect(Collectors.toList());





----------> pegando numeros pares e maiores que 2 e colocar em um alista

List<Integer> listParesMaioresQue2 = numerosAleaorios.stream()
	.map(Integer::parseInt)
	.filter(new Predicate<Integer>() {
		@Override
		public boolean test(Integer i) {
			if (i %2 == 0 && i > 2) return true
			return false;
		}
	}).collect(Collections.toList());


----------> simplicicando para lambda expression

List<Integer> listParesMaioresQue2 = numerosAleaorios.stream()
	.map(Integer::parseInt)
	.filter(i -> (i %2 == 0 && i > 2))
	.collect(Collections.toList());




-----------> mostrando a media dos numeros

numerosAleatorios.stream()
	.mapToInt(new ToIntfunction<String>() {
		@Override
		public int applyAsInt(String s) {
			return Integer.parseInt(s);
		}
	});


----------> simplificando

---> parte 1 - para lambda
numerosAleatorios.stream()
	.mapToInt(s -> Integer.parseInt(s));
	
---> parte 2 - para reference method
numerosAleatorios.stream()
	.mapToInt(Integer::parseInt);

---> retornando media
numerosAleatorios.stream()
	.mapToInt(Integer::parseInt)
	.average()
	.ifPresent(new DoubleConsumer() {
		@Override
		public void accept(double v) {
			System.out.println(v);
		}
	});


------> simplificando lambda expression

numerosAleatorios.stream()
	.mapToInt(Integer::parseInt)
	.average()
	.ifPresent(v -> System.out.println(v));

-----> simplificando para reference method

numerosAleatorios.stream()
	.mapToInt(Integer::parseInt)
	.average()
	.ifPresent(System.out::println);




------> removendo após transformar para inteiros

numerosAleatoriosInteiros.removeIf(new Predicate<Integer>() {
	@Override
	public boolean test(Integer i) {
		if (i %2 != 0) return true;
		return false;
	}
});

-------> simplificando para lambda expression

numerosAleatoriosInteiros.removeIf(i -> (i %2 != 0));


-------> resolver exercicios <-------
https://github.com/cami-la/curso-dio-intro-collections